{"ast":null,"code":"var _jsxFileName = \"/Users/jcfloresg/Cursos/REACT/agrak-react-challenge/src/issues/views/User.tsx\";\nimport { Link } from 'react-router-dom';\n// import { IssueComment } from '../components/IssueComment';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst comment1 = \"It would provide the ability to create a state, read the state \\r\\nand set the state form anywhere in the code base.\\r\\n\\r\\nIt would be something like this:\\r\\n\\r\\n## adding the state to the global state\\r\\n\\r\\n```js\\r\\nimport {useGlobalState} from 'react';\\r\\nconst ProviderComponent = ()=>{\\r\\n\\r\\n  const [ceateState, _, _] = useGlobalState();\\r\\n\\r\\n  createState('provider', 'stateName', 'state value');\\r\\n  createState('provider', 'otherStateName', 'another state value');\\r\\n  // or maybe, set all the states in one line\\r\\n  createState('provider', {stateName: 'state value', anotherStateName: 'another state value'});\\r\\n\\r\\n  return <></>\\r\\n}\\r\\n```\\r\\n\\r\\n##  now I can use it like so:\\r\\n\\r\\n```js\\r\\nimport {useGlobalState} from 'react';\\r\\n\\r\\nconst ConsumerComponent = ()=>{\\r\\n  \\r\\n  const [_, getState, setState] = useGlobalState();\\r\\n\\r\\n  const providerStateCpy = getState('key', 'stateName');\\r\\n\\r\\n  const changeProviderState = ()=>{\\r\\n    setState('key', 'stateName', 'new state value');\\r\\n  }\\r\\n  return <p onClick={changeProviderState}>{providerStateCpy}</p>\\r\\n}\\r\\n```\\r\\nI wonder if it's a possible thing without making major changes though.\";\nconst comment2 = \"In order to familiarize myself with react codebase, I wrote a small test that fails on this pattern. (even if it is expected so)\\r\\n\\r\\nHere is it fwiw (in `packages/react-reconciler/src/__tests__/useSyncExternalStore-test.js`):\\r\\n\\r\\n```js\\r\\ntest('store value is correctly stored in current hook instance even with interleaved effects occurring', async () => {\\r\\n    const store = createExternalStore('value:initial');\\r\\n\\r\\n    function App() {\\r\\n      const value = useSyncExternalStore(store.subscribe, store.getState);\\r\\n      const [sameValue, setSameValue] = useState(value);\\r\\n      if (value !== sameValue) setSameValue(value);\\r\\n      return <Text text={value} />;\\r\\n    }\\r\\n\\r\\n    const root = ReactNoop.createRoot();\\r\\n    act(() => {\\r\\n      // Start a render that reads from the store and yields value\\r\\n      root.render(<App />);\\r\\n    });\\r\\n    expect(Scheduler).toHaveYielded(['value:initial']);\\r\\n\\r\\n    await act(() => {\\r\\n      store.set('value:changed');\\r\\n    });\\r\\n    expect(Scheduler).toHaveYielded(['value:changed']);\\r\\n\\r\\n    await act(() => {\\r\\n      store.set('value:initial');\\r\\n    });\\r\\n    expect(Scheduler).toHaveYielded(['value:initial']); \\r\\n  });\\r\\n});\\r\\n```\\r\\n\\r\\nThe last assertion fails with the `setSameValue` line, and passes without.\";\nconst comment3 = \"What I don't understand is that in `renderWithHooks`, there is the following block:\\r\\n\\r\\n```js\\r\\n// Check if there was a render phase update\\r\\n  if (didScheduleRenderPhaseUpdateDuringThisPass) {\\r\\n```\\r\\n\\r\\nWhich runs if `setState` was called in render. Then, it calls again component function - but to do so, it resets the `workInProgress` state, including `updateQueue`. IIUC this discards the effects pushed by previous hooks, without flushing them?\\r\\n\\r\\nThat's why `useSyncExternalStore` effect to update store value is not run, in that case.\\r\\n\\r\\nThe fact that there is code written to manage `setState` calls in render, seem to acknowledge it is a legit use case?\\r\\n\\r\\nI must be missing something ðŸ˜… how to make sure those effects are run even if component function is called again before end of work?\";\nexport const User = () => {\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"row mt-5\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"col-12 mb-3\",\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        children: \"List User\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 14,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(Link, {\n        to: \"./issues/list\",\n        children: \"Go Back\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 16,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 13,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"hr\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 18,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      type: \"button\",\n      className: \"btn btn-outline-primary\",\n      children: \" Add User\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 19,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 12,\n    columnNumber: 9\n  }, this);\n};\n_c = User;\nvar _c;\n$RefreshReg$(_c, \"User\");","map":{"version":3,"names":["Link","comment1","comment2","comment3","User"],"sources":["/Users/jcfloresg/Cursos/REACT/agrak-react-challenge/src/issues/views/User.tsx"],"sourcesContent":["import { Link } from 'react-router-dom';\n// import { IssueComment } from '../components/IssueComment';\n\nconst comment1 = \"It would provide the ability to create a state, read the state \\r\\nand set the state form anywhere in the code base.\\r\\n\\r\\nIt would be something like this:\\r\\n\\r\\n## adding the state to the global state\\r\\n\\r\\n```js\\r\\nimport {useGlobalState} from 'react';\\r\\nconst ProviderComponent = ()=>{\\r\\n\\r\\n  const [ceateState, _, _] = useGlobalState();\\r\\n\\r\\n  createState('provider', 'stateName', 'state value');\\r\\n  createState('provider', 'otherStateName', 'another state value');\\r\\n  // or maybe, set all the states in one line\\r\\n  createState('provider', {stateName: 'state value', anotherStateName: 'another state value'});\\r\\n\\r\\n  return <></>\\r\\n}\\r\\n```\\r\\n\\r\\n##  now I can use it like so:\\r\\n\\r\\n```js\\r\\nimport {useGlobalState} from 'react';\\r\\n\\r\\nconst ConsumerComponent = ()=>{\\r\\n  \\r\\n  const [_, getState, setState] = useGlobalState();\\r\\n\\r\\n  const providerStateCpy = getState('key', 'stateName');\\r\\n\\r\\n  const changeProviderState = ()=>{\\r\\n    setState('key', 'stateName', 'new state value');\\r\\n  }\\r\\n  return <p onClick={changeProviderState}>{providerStateCpy}</p>\\r\\n}\\r\\n```\\r\\nI wonder if it's a possible thing without making major changes though.\";\nconst comment2 = \"In order to familiarize myself with react codebase, I wrote a small test that fails on this pattern. (even if it is expected so)\\r\\n\\r\\nHere is it fwiw (in `packages/react-reconciler/src/__tests__/useSyncExternalStore-test.js`):\\r\\n\\r\\n```js\\r\\ntest('store value is correctly stored in current hook instance even with interleaved effects occurring', async () => {\\r\\n    const store = createExternalStore('value:initial');\\r\\n\\r\\n    function App() {\\r\\n      const value = useSyncExternalStore(store.subscribe, store.getState);\\r\\n      const [sameValue, setSameValue] = useState(value);\\r\\n      if (value !== sameValue) setSameValue(value);\\r\\n      return <Text text={value} />;\\r\\n    }\\r\\n\\r\\n    const root = ReactNoop.createRoot();\\r\\n    act(() => {\\r\\n      // Start a render that reads from the store and yields value\\r\\n      root.render(<App />);\\r\\n    });\\r\\n    expect(Scheduler).toHaveYielded(['value:initial']);\\r\\n\\r\\n    await act(() => {\\r\\n      store.set('value:changed');\\r\\n    });\\r\\n    expect(Scheduler).toHaveYielded(['value:changed']);\\r\\n\\r\\n    await act(() => {\\r\\n      store.set('value:initial');\\r\\n    });\\r\\n    expect(Scheduler).toHaveYielded(['value:initial']); \\r\\n  });\\r\\n});\\r\\n```\\r\\n\\r\\nThe last assertion fails with the `setSameValue` line, and passes without.\";\nconst comment3 = \"What I don't understand is that in `renderWithHooks`, there is the following block:\\r\\n\\r\\n```js\\r\\n// Check if there was a render phase update\\r\\n  if (didScheduleRenderPhaseUpdateDuringThisPass) {\\r\\n```\\r\\n\\r\\nWhich runs if `setState` was called in render. Then, it calls again component function - but to do so, it resets the `workInProgress` state, including `updateQueue`. IIUC this discards the effects pushed by previous hooks, without flushing them?\\r\\n\\r\\nThat's why `useSyncExternalStore` effect to update store value is not run, in that case.\\r\\n\\r\\nThe fact that there is code written to manage `setState` calls in render, seem to acknowledge it is a legit use case?\\r\\n\\r\\nI must be missing something ðŸ˜… how to make sure those effects are run even if component function is called again before end of work?\";\n\n\nexport const User = () => {\n    return (\n\n        <div className=\"row mt-5\">\n            <div className=\"col-12 mb-3\">\n            <h1>List User</h1>\n\n                <Link to='./issues/list'>Go Back</Link>\n            </div>\n            <hr />\n            <button type=\"button\" className='btn btn-outline-primary'> Add User</button>\n        </div>\n    )\n}\n"],"mappings":";AAAA,SAASA,IAAI,QAAQ,kBAAkB;AACvC;AAAA;AAEA,MAAMC,QAAQ,GAAG,0pCAA0pC;AAC3qC,MAAMC,QAAQ,GAAG,6xCAA6xC;AAC9yC,MAAMC,QAAQ,GAAG,qzBAAqzB;AAGt0B,OAAO,MAAMC,IAAI,GAAG,MAAM;EACtB,oBAEI;IAAK,SAAS,EAAC,UAAU;IAAA,wBACrB;MAAK,SAAS,EAAC,aAAa;MAAA,wBAC5B;QAAA,UAAI;MAAS;QAAA;QAAA;QAAA;MAAA,QAAK,eAEd,QAAC,IAAI;QAAC,EAAE,EAAC,eAAe;QAAA,UAAC;MAAO;QAAA;QAAA;QAAA;MAAA,QAAO;IAAA;MAAA;MAAA;MAAA;IAAA,QACrC,eACN;MAAA;MAAA;MAAA;IAAA,QAAM,eACN;MAAQ,IAAI,EAAC,QAAQ;MAAC,SAAS,EAAC,yBAAyB;MAAA,UAAC;IAAS;MAAA;MAAA;MAAA;IAAA,QAAS;EAAA;IAAA;IAAA;IAAA;EAAA,QAC1E;AAEd,CAAC;AAAA,KAbYA,IAAI;AAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}